#include "SimpleCppLogger/ConsoleAppenderTest.h"

#include <iostream>
#include <source_location>
#include <string>

using namespace SimpleCppLogger;

std::ostringstream ConsoleAppenderTest::m_cout_stream;
std::ostringstream ConsoleAppenderTest::m_cerr_stream;

/**
 * @brief Sets up the test fixture for each test.
 *
 * This method initializes the ConsoleAppender with a SimpleFormatter and redirects
 * std::cout and std::cerr to internal string streams to capture console output during tests.
 * The original stream buffers are saved for later restoration in TearDown().
 */
void ConsoleAppenderTest::SetUp()
{
    m_console_appender = std::make_shared<ConsoleAppender>(std::make_shared<SimpleFormatter>());
    m_cout_buf = std::cout.rdbuf();
    m_cerr_buf = std::cerr.rdbuf();
    m_cout_stream.str("");
    m_cerr_stream.str("");
    std::cout.rdbuf(m_cout_stream.rdbuf());
    std::cerr.rdbuf(m_cerr_stream.rdbuf());
}

/**
 * @brief Tears down the test fixture after each test.
 *
 * This method restores the original std::cout and std::cerr stream buffers
 * and resets the ConsoleAppender instance.
 */
void ConsoleAppenderTest::TearDown()
{
    std::cout.rdbuf(m_cout_buf);
    std::cerr.rdbuf(m_cerr_buf);
    m_console_appender.reset();
}

/**
 * @brief Captures the console output generated by a given function.
 *
 * This method clears the internal string streams, executes the provided function,
 * and returns the combined output from std::cout and std::cerr as a single string.
 *
 * @param func The function whose console output is to be captured.
 * @return A string containing the captured console output.
 */
auto ConsoleAppenderTest::capture_console_output(std::function<void()> func) -> std::string
{
    m_cout_stream.str("");
    m_cerr_stream.str("");
    func();
    return m_cout_stream.str() + m_cerr_stream.str();
}

/**
 * @brief Tests that a log message is correctly appended to the console.
 */
TEST_F(ConsoleAppenderTest, LogMessageIsAppended)
{
    LogMessage msg(LogLevel::Info, "Test message");
    SimpleFormatter formatter;
    auto location = std::source_location::current();
    auto expected = formatter.format(msg, location);

    std::string output =
        capture_console_output([&, location]() { m_console_appender->append(msg, location); });

    ASSERT_NE(output.find(expected), std::string::npos);
}

/**
 * @brief Tests that log messages with different levels are correctly appended to the console.
 */
TEST_F(ConsoleAppenderTest, LogMessageWithDifferentLevels)
{
    struct TestCase {
            LogLevel level;
            std::string message;
    };

    std::vector<TestCase> test_cases = {{LogLevel::Debug, "Debug message"},
                                        {LogLevel::Info, "Info message"},
                                        {LogLevel::Warning, "Warning message"},
                                        {LogLevel::Error, "Error message"},
                                        {LogLevel::Fatal, "Fatal message"}};

    SimpleFormatter formatter;

    for (const auto& test_case: test_cases)
    {
        LogMessage msg(test_case.level, test_case.message);
        auto location = std::source_location::current();
        auto expected = formatter.format(msg, location);

        std::string output =
            capture_console_output([&, location]() { m_console_appender->append(msg, location); });

        ASSERT_NE(output.find(expected), std::string::npos);
    }
}

/**
 * @brief Tests that the found message matches the formatting of the SimpleFormatter.
 */
TEST_F(ConsoleAppenderTest, FoundMessageMatchesSimpleFormatter)
{
    LogMessage msg(LogLevel::Debug, "Formatted message test");
    SimpleFormatter formatter;
    auto location = std::source_location::current();
    auto expected = formatter.format(msg, location);

    std::string output =
        capture_console_output([&, location]() { m_console_appender->append(msg, location); });

    ASSERT_NE(output.find(expected), std::string::npos);
}

/**
 * @brief Tests that log messages below the log level are not appended to the console.
 */
TEST_F(ConsoleAppenderTest, LogMessageBelowLogLevelIsNotAppended)
{
    m_console_appender->set_log_level(LogLevel::Warning);

    LogMessage msg(LogLevel::Debug, "This message should not appear");
    SimpleFormatter formatter;
    auto location = std::source_location::current();
    auto expected = formatter.format(msg, location);

    std::string output =
        capture_console_output([&, location]() { m_console_appender->append(msg, location); });

    ASSERT_EQ(output.find(expected), std::string::npos);
}

/**
 * @brief Tests that log messages at or above the log level are appended to the console.
 */
TEST_F(ConsoleAppenderTest, LogMessageAtOrAboveLogLevelIsAppended)
{
    m_console_appender->set_log_level(LogLevel::Warning);

    struct TestCase {
            LogLevel level;
            std::string message;
    };

    std::vector<TestCase> test_cases = {{LogLevel::Warning, "Warning message"},
                                        {LogLevel::Error, "Error message"},
                                        {LogLevel::Fatal, "Fatal message"}};

    SimpleFormatter formatter;

    for (const auto& test_case: test_cases)
    {
        LogMessage msg(test_case.level, test_case.message);
        auto location = std::source_location::current();
        auto expected = formatter.format(msg, location);

        std::string output =
            capture_console_output([&, location]() { m_console_appender->append(msg, location); });

        ASSERT_NE(output.find(expected), std::string::npos);
    }
}

/**
 * @brief Tests that the log level can be changed dynamically.
 */
TEST_F(ConsoleAppenderTest, LogLevelCanBeChangedDynamically)
{
    m_console_appender->set_log_level(LogLevel::Warning);

    LogMessage msg(LogLevel::Debug, "This message should not appear");
    SimpleFormatter formatter;
    auto location = std::source_location::current();
    auto expected = formatter.format(msg, location);

    std::string output =
        capture_console_output([&, location]() { m_console_appender->append(msg, location); });

    ASSERT_EQ(output.find(expected), std::string::npos);

    m_console_appender->set_log_level(LogLevel::Debug);

    output = capture_console_output([&, location]() { m_console_appender->append(msg, location); });

    ASSERT_NE(output.find(expected), std::string::npos);
}
